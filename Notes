Why Engine?
3. Finding key information from gigantic World Wide Web is similar to find a needle lost in haystack. For this purpose we would use a special magnet that would automatically, quickly and effortlessly attract that needle for us. In this scenario magnet is “Search Engine”
4. “ Even a blind squirrel finds a nut , occasionally.” But few of us are determined enough to search through millions, or billions, of pages of information to find our “nut.” So, to reduce the problem to a, more or less, manageable solution, web “search engines” were introduced a few years ago.
5. A software program that searches a database and gathers and reports information that contains or is related to specified terms. OR A website whose primary function is providing a search for gathering and reporting information available on the Internet or a portion of the Internet . S e a r c h E n g i n e
6. Eight reasonably well-known Web search engines are : -
7. Top 10 Search Providers by Searches, August 2007 Provider Searches (000) Share of Total Searches (%) 4,199,495 53.6 1,561,903 19.9 1,011,398 12.9 435,088 5.6 136,853 1.7 71,724 0.9 37,762 0.5 34,699 0.4 32,483 0.4 31,912 0.4 Other 275,812 3.5 All Search 7,829,129 100.0 Source: Nielsen//NetRatings, 2007
8. 1990 - The first search engine Archie was released . There was no World Wide Web at the time. Data resided on defense contractor , university, and government computers, and techies were the only people accessing the data. The computers were interconnected by Telenet . File Transfer Protocol (FTP) used for transferring files from computer to computer. There was no such thing as a browser. Files were transferred in their native format and viewed using the associated file type software. Archie searched FTP servers and indexed their files into a searchable directory. S e a r c h E n g i n e History
9. 1991 - Gopherspace came into existence with the advent of Gopher. Gopher cataloged FTP sites, and the resulting catalog became known as Gopherspace . 1994 - WebCrawler, a new type of search engine that indexed the entire content of a web page , was introduced. Telenet / FTP passed information among the new web browsers accessing not FTP sites but WWW sites. Webmasters and web site owners begin submitting sites for inclusion in the growing number of web directories.
10. 1995 - Meta tags in the web page were first utilized by some search engines to determine relevancy. 1997 - Search engine rank-checking software was introduced. It provides an automated tool to determine web site position and ranking within the major search engines. 1998 - Search engine algorithms begin incorporating esoteric information in their ranking algorithms. E.g. Inclusion of the number of links to a web site to determine its “link popularity.” Another ranking approach was to determine the number of clicks (visitors) to a web site based upon keyword and phrase relevancy.
11. 2000 - Marketers determined that pay-per click campaigns were an easy yet expensive approach to gaining top search rankings. To elevate sites in the search engine rankings web sites started adding useful and relevant content while optimizing their web pages for each specific search engine.
14. <ul><ul><li>Finding documents: It is potentially needed to find interesting documents on the Web consists of millions of documents, distributed over tens of thousands of servers. </li></ul></ul><ul><ul><li>Formulating queries: It needed to express exactly what kind of information is to retrieve. </li></ul></ul><ul><ul><li>Determining relevance: T he system must determine whether a document contains the required information or not. </li></ul></ul>Stages in information retrieval
15. Types of S e a r c h E n g i n e <ul><li>On the basis of working, Search engine is categories in following group :- </li></ul><ul><ul><li>Crawler-Based Search Engines </li></ul></ul><ul><ul><li>Directories </li></ul></ul><ul><ul><li>Hybrid Search Engines </li></ul></ul><ul><ul><li>Meta Search Engines </li></ul></ul>
16. <ul><li>It uses automated software programs to survey and categories web pages , which is known as ‘spiders’, ‘crawlers’, ‘robots’ or ‘bots’. </li></ul><ul><li>A spider will find a web page, download it and analyses the information presented on the web page. The web page will then be added to the search engine’s database. </li></ul><ul><li>When a user performs a search, the search engine will check its database of web pages for the key words the user searched. </li></ul><ul><li>The results (list of suggested links to go to), are listed on pages by order of which is ‘closest’ (as defined by the ‘bots). Examples of crawler-based search engines are: </li></ul><ul><ul><ul><ul><li>Google ( www.google.com ) </li></ul></ul></ul></ul><ul><ul><ul><ul><li>Ask Jeeves ( www.ask.com ) </li></ul></ul></ul></ul>Crawler-Based Search Engines
17. <ul><li>All robots use the following algorithm for retrieving documents from the Web: </li></ul><ul><ul><li>The algorithm uses a list of known URLs. This list contains at least one URL to start with. </li></ul></ul><ul><ul><li>A URL is taken from the list, and the corresponding document is retrieved from the Web. </li></ul></ul><ul><ul><li>The document is parsed to retrieve information for the index database and to extract the embedded links to other documents. </li></ul></ul><ul><ul><li>The URLs of the links found in the document are added to the list of known URLs. </li></ul></ul><ul><ul><li>If the list is empty or some limit is exceeded (number of documents retrieved, size of the index database, time elapsed since startup, etc.) the algorithm stops. otherwise the algorithm continues at step 2. </li></ul></ul>Robot Algorithm
18. <ul><li>Crawler program treated World Wide Web as big graph having pages as nodes And the hyperlinks as arcs. </li></ul><ul><li>Crawler works with a simple goal: indexing all the keywords in web pages’ titles. </li></ul><ul><li>Three data structure is needed for crawler or robot algorithm </li></ul><ul><ul><ul><ul><li>A large linear array , url_table </li></ul></ul></ul></ul><ul><ul><ul><ul><li>Heap </li></ul></ul></ul></ul><ul><ul><ul><ul><li>Hash table </li></ul></ul></ul></ul>
19. <ul><li>Url_table : </li></ul><ul><ul><li>It is a large linear array that contains millions of entries </li></ul></ul><ul><ul><li>Each entry contains two pointers – </li></ul></ul><ul><ul><ul><li>Pointer to URL </li></ul></ul></ul><ul><ul><ul><li>Pointer to title </li></ul></ul></ul><ul><ul><ul><li>These are variable length strings and kept on heap </li></ul></ul></ul><ul><li>Heap </li></ul><ul><ul><li>It is a large unstructured chunk of virtual memory to which strings can be appended. </li></ul></ul>
20. <ul><li>Hash table : </li></ul><ul><ul><li>It is third data structure of size ‘n’ entries. </li></ul></ul><ul><ul><li>Any URL can be run through a hash function to produce a nonnegative integer less than ‘n’. </li></ul></ul><ul><ul><li>All URL that hash to the value ‘k’ are hooked together on a linked list starting at the entry ‘k’ of the hash table. </li></ul></ul><ul><ul><li>Every entry into url_table is also entered into hash table </li></ul></ul><ul><ul><li>The main use of hash table is to start with a URL and be able to quickly determine whether it is already present in url_table. </li></ul></ul>
21. U URL URL Title Title 6 44 19 21 5 4 2 Pointers to URL Pointers to title Overflow chains Heap Url_table Hash table String storage Hash Code 0 1 2 3 n Data structure for crawler
22. <ul><li>Building the index requires two phases : </li></ul><ul><ul><li>Searching (URL proceesing ) </li></ul></ul><ul><ul><li>Indexing. </li></ul></ul><ul><li>The heart of the search engine is a recursive procedure procees_url, which takes a URL string as input. </li></ul>
23. <ul><li>Searching is done by procedure, procees_url as follows :- </li></ul><ul><li>It hashes the URL to see if it is already present in url_table. If so, it is done and returns immediately. </li></ul><ul><li>If the URL is not already known, its page is fetched. </li></ul><ul><li>The URL and title are then copied to the heap and pointers to these two strings are entered in url_table. </li></ul><ul><li>The URL is also entered into the hash table. </li></ul><ul><li>Finally, process_url extracts all the hyperlinks from the page and calls process_url once per hyperlink, passing the hyperlink’s URL as the input parameter </li></ul>
24. <ul><li>This design is simple and theoretically correct, but it has a serious problem </li></ul><ul><li>Depth-first search is used which may cause recursion . </li></ul><ul><li>Path-length is not pridictable it may be thousands of hyperlinks long which cause memory problem such as ,stack overflow . </li></ul>
25. <ul><li>Solution </li></ul><ul><li>Processed URL s are removed from the list and Breadth-first search is used to limit path-length </li></ul><ul><li>To avoid memory problem pointed pages are not traced in same order as they obtained. </li></ul>
26. For each entry in url_table, indexing procedure will examine the title and selects out all words not on the stop list. Each selected word is written on to a file with a line consisting of the word followed by the current url_table entry number. when the whole table has been scanned , the file is shorted by word. keyword Indexing The stop list prevents indexing of prepositions, conjunctions, articles, and other words with many hits and little value.
27. Formulating Queries <ul><li>Keyword submission cause a POST request to be done to a CGI script on the machine where the index is located. </li></ul><ul><li>The CGI script then looks up the keyword in the index to find the set of URl_table indices for each keyword . </li></ul><ul><li>if the user wants the Boolean and of the keywords the set intersection is computed. </li></ul><ul><li>If the Boolean or is desired the set union is computed. </li></ul><ul><li>The script now indexes into url_table to find all the titles and urls. These are then combined to form a web page and sent back to user as the response of the POST . </li></ul>
28. Determining Relevance <ul><li>Classic algorithm &quot;TF / IDF“ is used for determining relevance. </li></ul><ul><li>It is a weight often used in information retrieval and text mining.This weight is a statistical measure used to evaluate how important a word is to a document in a collection </li></ul><ul><li>A high weight in tf–idf is reached by a high term frequency (in the given document) and a low document frequency of the term in the whole collection of documents </li></ul>
29. Term Frequency <ul><li>The “term frequency” in the given document is simply the number of times a given term appears in that document. </li></ul><ul><li>It gives a measure of the importance of the term t i within the particular document. </li></ul><ul><li>Term Frequency, </li></ul><ul><li>where n i is the number of occurrences of the considered term, and the denominator is the number of occurrences of all terms. </li></ul>
30. Term Frequency <ul><li>The term frequency (TF) is the number of times the word appears in a document divided by the number of total words in the document. </li></ul><ul><ul><li>For Example , </li></ul></ul><ul><ul><li>If a document contains 100 total words and the word computer appears 3 times, then the term frequency of the word computer in the document is 0.03 (3/100) </li></ul></ul>
31. Inverse Document Frequency <ul><li>The “ inverse document frequency ” is a measure of the general importance of the term (obtained by dividing the number of all documents by the number of documents containing the term, and then taking the logarithm of that quotient). </li></ul><ul><li>Where, </li></ul><ul><li>| D | : total number of documents in the corpus </li></ul><ul><li>  : number of documents where the term t i appears (that is ). </li></ul>
32. Inverse Document Frequency <ul><li>There are many different formulas used to calculate tf–idf. </li></ul><ul><li>One way of calculating “document frequency” (DF) is to determine how many documents contain the word and divide it by the total number of documents in the collection. </li></ul><ul><ul><ul><li>For Example , If the word computer appears in 1,000 documents out of a total of 10,000,000 then the document frequency is 0.0001 (1000/10,000,000). </li></ul></ul></ul><ul><ul><ul><li>Alternatives to this formula are to take the log of the document frequency. The natural logarithm is commonly used. In this example we would have </li></ul></ul></ul><ul><li> idf = ln(1,000 / 10,000,000) =1/ 9.21 </li></ul>
33. Inverse Document Frequency <ul><ul><li>The final tf-idf score is then calculated by dividing the “term frequency” by the “document frequency” . </li></ul></ul><ul><ul><ul><li>For our example, the tf-idf score for computer in the collection would be : </li></ul></ul></ul><ul><ul><li>tf-idf = 0.03/0.0001= 300 , by using first formula of idf. </li></ul></ul><ul><ul><li>If alternate formula used we would have </li></ul></ul><ul><ul><li>tf-idf = 0.03 * 9.21 = 0.27. </li></ul></ul>
34. <ul><li>A ‘directory’ uses human editors who decide what category the site belongs to. </li></ul><ul><li>They place websites within specific categories or subcategories in the ‘directories’ database. </li></ul><ul><li>By focusing on particular categories and subcategories, user can narrow the search to those records that are most likely to be relevant to his/her interests. </li></ul>Directories
35. <ul><li>The human editors comprehensively check the website and rank it, based on the information they find, using a pre-defined set of rules. </li></ul><ul><li>There are two major directories : </li></ul><ul><ul><ul><ul><li>Yahoo Directory ( www.yahoo.com ) </li></ul></ul></ul></ul><ul><ul><ul><ul><li>Open Directory ( www.dmoz.org ) </li></ul></ul></ul></ul>Directories
36. <ul><li>Hybrid search engines use a combination of both crawler-based results and directory results. </li></ul><ul><li>Examples of hybrid search engines are: </li></ul><ul><ul><ul><ul><li>Yahoo ( www.yahoo.com ) </li></ul></ul></ul></ul><ul><ul><ul><ul><li>Google ( www.google.com ) </li></ul></ul></ul></ul><ul><ul><li>Hybrid Search Engines </li></ul></ul>
37. <ul><li>Also known as Multiple Search Engines or Metacrawlers. </li></ul><ul><li>Meta search engines query several other Web search engine databases in parallel and then combine the results in one list. </li></ul><ul><li>Examples of Meta search engines include: </li></ul><ul><ul><ul><ul><li>Metacrawler ( www.metacrawler.com ) </li></ul></ul></ul></ul><ul><ul><ul><ul><li>Dogpile ( www.dogpile.com ) </li></ul></ul></ul></ul>Meta Search Engines
38. <ul><li>Pros :- </li></ul><ul><ul><li>Easy to use </li></ul></ul><ul><ul><li>Able to search more web pages in less time. </li></ul></ul><ul><ul><li>High probability of finding the desired page(s) </li></ul></ul><ul><ul><li>It will get at least some results when no result had been obtained with traditional search engines. </li></ul></ul>Pros and Cons of Meta Search Engines
39. <ul><li>Cons :- </li></ul><ul><ul><li>Metasearch engine results are less relevant, since it doesn’t know the internal “alchemy” of search engine used. </li></ul></ul><ul><ul><li>Since, only top 10-50 hits are retrieved from each search engine, the total number of hits retrieved may be considerably less than found by doing a direct search. </li></ul></ul><ul><ul><li>Advanced search features (like, searches with boolean operators and field limiting ; use of &quot; &quot;, +/-. default AND between words e.t.c.) are not usually available. </li></ul></ul>Pros and Cons of Meta Search Engines
40. Meta Search Engines Cont…. Meta-Search Engine Primary Web Databases Ad Databases Special Features Vivisimo Ask, MSN, Gigablast, Looksmart, Open Directory, Wisenut Google Clusters results Clusty Ask, MSN, Gigablast, Looksmart, Open Directory, Wisenut Google Clusters results Ixquick AltaVista, EntireWeb, Gigablast, Go, Looksmart,Netscape, Open Directory,Wisenut, Yahoo Yahoo Dogpile Ask, Google, MSN, Yahoo!, Teoma, Open Directory, more Google, Yahoo All top 4 engines Mamma About, Ask, Business.com, EntireWeb, Gigablast, Open Directory,Wisenut Miva, Ask Refine options Kartoo AlltheWeb, AltaVista, EntireWeb, Exalead, Hotbot, Looksmart, Lycos, MSN, Open Directory, Teoma, ToileQuebec, Voila, Wisenut, Yahoo ?? Visual results display
41. <ul><li>&quot;Real&quot; MSEs which aggregate/rank the results in one page </li></ul><ul><li>&quot;Pseudo&quot; MSEs type I which exclusively group the results by search engine </li></ul><ul><li>&quot;Pseudo&quot; MSEs type II which open a separate browser window for each search engine used and </li></ul><ul><li>Search Utilities, software search tools. </li></ul>Meta Search Engines (MSEs) Come In Four Flavors
42. T H A N K Y O U
